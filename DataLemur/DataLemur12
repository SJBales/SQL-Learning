-- Original Query, way too complicated
WITH backbone AS (
SELECT c.customer_id,
       p.product_id
FROM customer_contracts c
CROSS JOIN products p),

composite AS (SELECT b.customer_id,
       b.product_id,
       p.product_category,
       t.amount
FROM backbone b
LEFT JOIN products p ON b.product_id = p.product_id
LEFT JOIN customer_contracts t ON b.customer_id = t.customer_id 
   AND b.product_id = t.product_id),

aggregate AS (SELECT customer_id, 
       product_category,
       SUM(amount) AS purchased
FROM composite
GROUP BY customer_id, product_category
ORDER BY customer_id),

grouped AS (
SELECT customer_id,
       COUNT(purchased) as categories_bought
FROM aggregate
GROUP BY customer_id
HAVING COUNT(purchased) = 3)

SELECT customer_id
FROM grouped;

-- Second attempt, much simpler
WITH purchase_categories AS (SELECT DISTINCT c.customer_id,
       p.product_category
FROM customer_contracts c
JOIN products p ON c.product_id = p.product_id),

totals AS (SELECT customer_id,
       COUNT(product_category) AS total_categories
FROM purchase_categories
GROUP BY customer_id)

SELECT customer_id
FROM totals
WHERE total_categories = 3

-- DataLemur Solution
WITH supercloud_cust AS (
  SELECT 
    customers.customer_id, 
    COUNT(DISTINCT products.product_category) AS product_count
  FROM customer_contracts AS customers
  INNER JOIN products 
    ON customers.product_id = products.product_id
  GROUP BY customers.customer_id
)

SELECT customer_id
FROM supercloud_cust
WHERE product_count = (
  SELECT COUNT(DISTINCT product_category) FROM products
)

/*
Key learnings: 
1) I can compress my two CTE's into one by using a count-distinct
2) My query should be more robust by dynamically counting unique categories from the products table

*/
